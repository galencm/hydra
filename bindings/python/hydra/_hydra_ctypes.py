################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################

from __future__ import print_function
import os, sys
from ctypes import *
from ctypes.util import find_library
import czmq

# load libc to access free, etc.
libcpath = find_library("c")
if not libcpath:
    raise ImportError("Unable to find libc")
libc = cdll.LoadLibrary(libcpath)
libc.free.argtypes = [c_void_p]
libc.free.restype = None

def return_fresh_string(char_p):
    s = string_at(char_p)
    libc.free(char_p)
    return s

# hydra
lib = None
# check to see if the shared object was embedded locally, attempt to load it
# if not, try to load it using the default system paths...
# we need to use os.chdir instead of trying to modify $LD_LIBRARY_PATH and reloading the interpreter
t = os.getcwd()
p = os.path.join(os.path.dirname(__file__), '..')  # find the path to our $project_ctypes.py
os.chdir(p)  # change directories briefly

try:
    from hydra import libhydra                      # attempt to import the shared lib if it exists
    lib = CDLL(libhydra.__file__)            # if it exists try to load the shared lib
except ImportError:
    pass
finally:
    os.chdir(t)  # switch back to orig dir

if not lib:
    try:
        # If LD_LIBRARY_PATH or your OSs equivalent is set, this is the only way to
        # load the library.  If we use find_library below, we get the wrong result.
        if os.name == 'posix':
            if sys.platform == 'darwin':
                lib = cdll.LoadLibrary('libhydra.0.dylib')
            else:
                lib = cdll.LoadLibrary("libhydra.so.0")
        elif os.name == 'nt':
            lib = cdll.LoadLibrary('libhydra.dll')
    except OSError:
        libpath = find_library("hydra")
        if not libpath:
            raise ImportError("Unable to find libhydra")
        lib = cdll.LoadLibrary(libpath)

class hydra_t(Structure):
    pass # Empty - only for type checking
hydra_p = POINTER(hydra_t)

class hydra_post_t(Structure):
    pass # Empty - only for type checking
hydra_post_p = POINTER(hydra_post_t)

class hydra_proto_t(Structure):
    pass # Empty - only for type checking
hydra_proto_p = POINTER(hydra_proto_t)

class hydra_ledger_t(Structure):
    pass # Empty - only for type checking
hydra_ledger_p = POINTER(hydra_ledger_t)


# hydra
lib.hydra_new.restype = hydra_p
lib.hydra_new.argtypes = [c_char_p]
lib.hydra_destroy.restype = None
lib.hydra_destroy.argtypes = [POINTER(hydra_p)]
lib.hydra_set_nickname.restype = None
lib.hydra_set_nickname.argtypes = [hydra_p, c_char_p]
lib.hydra_nickname.restype = c_char_p
lib.hydra_nickname.argtypes = [hydra_p]
lib.hydra_set_animate.restype = None
lib.hydra_set_animate.argtypes = [hydra_p]
lib.hydra_set_verbose.restype = None
lib.hydra_set_verbose.argtypes = [hydra_p]
lib.hydra_set_local_ipc.restype = None
lib.hydra_set_local_ipc.argtypes = [hydra_p]
lib.hydra_set_hostname.restype = None
lib.hydra_set_hostname.argtypes = [hydra_p, c_char_p]
lib.hydra_start.restype = c_int
lib.hydra_start.argtypes = [hydra_p]
lib.hydra_fetch.restype = hydra_post_p
lib.hydra_fetch.argtypes = [hydra_p]
lib.hydra_store_string.restype = POINTER(c_char)
lib.hydra_store_string.argtypes = [hydra_p, c_char_p, c_char_p, c_char_p, c_char_p]
lib.hydra_store_file.restype = POINTER(c_char)
lib.hydra_store_file.argtypes = [hydra_p, c_char_p, c_char_p, c_char_p, c_char_p]
lib.hydra_store_chunk.restype = POINTER(c_char)
lib.hydra_store_chunk.argtypes = [hydra_p, c_char_p, c_char_p, c_char_p, czmq.zchunk_p]
lib.hydra_version.restype = None
lib.hydra_version.argtypes = [POINTER(c_int), POINTER(c_int), POINTER(c_int)]
lib.hydra_test.restype = None
lib.hydra_test.argtypes = [c_bool]

class Hydra(object):
    """
    Main Hydra API
    """

    allow_destruct = False
    def __init__(self, *args):
        """
        Constructor, creates a new Hydra node. Note that until you start the
node it is silent and invisible to other nodes on the network. You may
specify the working directory, which defaults to .hydra in the current
working directory. Creates the working directory if necessary.
        """
        if len(args) == 2 and type(args[0]) is c_void_p and isinstance(args[1], bool):
            self._as_parameter_ = cast(args[0], hydra_p) # Conversion from raw type to binding
            self.allow_destruct = args[1] # This is a 'fresh' value, owned by us
        elif len(args) == 2 and type(args[0]) is hydra_p and isinstance(args[1], bool):
            self._as_parameter_ = args[0] # Conversion from raw type to binding
            self.allow_destruct = args[1] # This is a 'fresh' value, owned by us
        else:
            assert(len(args) == 1)
            self._as_parameter_ = lib.hydra_new(args[0]) # Creation of new raw type
            self.allow_destruct = True

    def __del__(self):
        """
        Destructor, destroys a Hydra node. When you destroy a node, any posts
it is sending or receiving will be discarded.
        """
        if self.allow_destruct:
            lib.hydra_destroy(byref(self._as_parameter_))

    def __eq__(self, other):
        if type(other) == type(self):
            return other.c_address() == self.c_address()
        elif type(other) == c_void_p:
            return other.value == self.c_address()

    def c_address(self):
        """
        Return the address of the object pointer in c.  Useful for comparison.
        """
        return addressof(self._as_parameter_.contents)

    def __bool__(self):
        "Determine whether the object is valid by converting to boolean" # Python 3
        return self._as_parameter_.__bool__()

    def __nonzero__(self):
        "Determine whether the object is valid by converting to boolean" # Python 2
        return self._as_parameter_.__nonzero__()

    def set_nickname(self, nickname):
        """
        Set node nickname; this is saved persistently in the Hydra configuration
file.
        """
        return lib.hydra_set_nickname(self._as_parameter_, nickname)

    def nickname(self):
        """
        Return our node nickname, as previously stored in hydra.cfg, or set by
the hydra_set_nickname() method. Caller must free returned string using
zstr_free ().
        """
        return lib.hydra_nickname(self._as_parameter_)

    def set_animate(self):
        """
        Set the trace level to animation of main actors; this is helpful to
debug the Hydra protocol flow.
        """
        return lib.hydra_set_animate(self._as_parameter_)

    def set_verbose(self):
        """
        Set the trace level to animation of all actors including those used in
security and discovery. Use this to collect diagnostic logs.
        """
        return lib.hydra_set_verbose(self._as_parameter_)

    def set_local_ipc(self):
        """
        By default, Hydra needs a network interface capable of broadcast UDP
traffic, e.g. WiFi or LAN interface. To run nodes on a stand-alone PC,
set the local IPC option. The node will then do gossip discovery over
IPC. Gossip discovery needs at exactly one node to be running in a
directory called ".hydra".
        """
        return lib.hydra_set_local_ipc(self._as_parameter_)

    def set_hostname(self, hostname):
        """
        By default, Hydra uses your hostname via zbeacon. Use this function to
set some other hostname. Useful when using VMs, containers, etc.
        """
        return lib.hydra_set_hostname(self._as_parameter_, hostname)

    def start(self):
        """
        Start node. When you start a node it begins discovery and post exchange.
Returns 0 if OK, -1 if it wasn't possible to start the node.
        """
        return lib.hydra_start(self._as_parameter_)

    def fetch(self):
        """
        Return next available post, if any. Does not block. If there are no posts
waiting, returns NULL. The caller can read the post using the hydra_post
API, and must destroy the post when done with it.
        """
        return HydraPost(lib.hydra_fetch(self._as_parameter_), True)

    def store_string(self, subject, parent_id, mime_type, content):
        """
        Store a new post provided as a null-terminated string. Returns post ID for
the newly created post, or NULL if it was impossible to store the post.
Caller must free post ID when finished with it.
        """
        return return_fresh_string(lib.hydra_store_string(self._as_parameter_, subject, parent_id, mime_type, content))

    def store_file(self, subject, parent_id, mime_type, filename):
        """
        Store a new post located in a file somewhere on disk. Returns post ID for
the newly created post, or NULL if it was impossible to store the post.
Caller must free post ID when finished with it.
        """
        return return_fresh_string(lib.hydra_store_file(self._as_parameter_, subject, parent_id, mime_type, filename))

    def store_chunk(self, subject, parent_id, mime_type, chunk):
        """
        Store a new post provided as a chunk of data. Returns post ID for
the newly created post, or NULL if it was impossible to store the post.
Caller must free post ID when finished with it.
        """
        return return_fresh_string(lib.hydra_store_chunk(self._as_parameter_, subject, parent_id, mime_type, chunk))

    @staticmethod
    def version(major, minor, patch):
        """
        Return the Hydra version for run-time API detection
        """
        return lib.hydra_version(byref(c_int.from_param(major)), byref(c_int.from_param(minor)), byref(c_int.from_param(patch)))

    @staticmethod
    def test(verbose):
        """
        Self test of this class
        """
        return lib.hydra_test(verbose)


# hydra_post
lib.hydra_post_new.restype = hydra_post_p
lib.hydra_post_new.argtypes = [c_char_p]
lib.hydra_post_destroy.restype = None
lib.hydra_post_destroy.argtypes = [POINTER(hydra_post_p)]
lib.hydra_post_ident.restype = c_char_p
lib.hydra_post_ident.argtypes = [hydra_post_p]
lib.hydra_post_subject.restype = c_char_p
lib.hydra_post_subject.argtypes = [hydra_post_p]
lib.hydra_post_timestamp.restype = c_char_p
lib.hydra_post_timestamp.argtypes = [hydra_post_p]
lib.hydra_post_parent_id.restype = c_char_p
lib.hydra_post_parent_id.argtypes = [hydra_post_p]
lib.hydra_post_mime_type.restype = c_char_p
lib.hydra_post_mime_type.argtypes = [hydra_post_p]
lib.hydra_post_digest.restype = c_char_p
lib.hydra_post_digest.argtypes = [hydra_post_p]
lib.hydra_post_location.restype = c_char_p
lib.hydra_post_location.argtypes = [hydra_post_p]
lib.hydra_post_content_size.restype = c_int
lib.hydra_post_content_size.argtypes = [hydra_post_p]
lib.hydra_post_content.restype = POINTER(c_char)
lib.hydra_post_content.argtypes = [hydra_post_p]
lib.hydra_post_set_parent_id.restype = None
lib.hydra_post_set_parent_id.argtypes = [hydra_post_p, c_char_p]
lib.hydra_post_set_mime_type.restype = None
lib.hydra_post_set_mime_type.argtypes = [hydra_post_p, c_char_p]
lib.hydra_post_set_content.restype = None
lib.hydra_post_set_content.argtypes = [hydra_post_p, c_char_p]
lib.hydra_post_set_data.restype = None
lib.hydra_post_set_data.argtypes = [hydra_post_p, c_void_p, c_int]
lib.hydra_post_set_file.restype = c_int
lib.hydra_post_set_file.argtypes = [hydra_post_p, c_char_p]
lib.hydra_post_save.restype = c_int
lib.hydra_post_save.argtypes = [hydra_post_p, c_char_p]
lib.hydra_post_load.restype = hydra_post_p
lib.hydra_post_load.argtypes = [c_char_p]
lib.hydra_post_fetch.restype = czmq.zchunk_p
lib.hydra_post_fetch.argtypes = [hydra_post_p, c_int, c_int]
lib.hydra_post_encode.restype = None
lib.hydra_post_encode.argtypes = [hydra_post_p, hydra_proto_p]
lib.hydra_post_decode.restype = hydra_post_p
lib.hydra_post_decode.argtypes = [hydra_proto_p]
lib.hydra_post_dup.restype = hydra_post_p
lib.hydra_post_dup.argtypes = [hydra_post_p]
lib.hydra_post_print.restype = None
lib.hydra_post_print.argtypes = [hydra_post_p]
lib.hydra_post_test.restype = None
lib.hydra_post_test.argtypes = [c_bool]

class HydraPost(object):
    """
    Main Hydra API
    """

    allow_destruct = False
    def __init__(self, *args):
        """
        Create a new post
        """
        if len(args) == 2 and type(args[0]) is c_void_p and isinstance(args[1], bool):
            self._as_parameter_ = cast(args[0], hydra_post_p) # Conversion from raw type to binding
            self.allow_destruct = args[1] # This is a 'fresh' value, owned by us
        elif len(args) == 2 and type(args[0]) is hydra_post_p and isinstance(args[1], bool):
            self._as_parameter_ = args[0] # Conversion from raw type to binding
            self.allow_destruct = args[1] # This is a 'fresh' value, owned by us
        else:
            assert(len(args) == 1)
            self._as_parameter_ = lib.hydra_post_new(args[0]) # Creation of new raw type
            self.allow_destruct = True

    def __del__(self):
        """
        Destroy the post
        """
        if self.allow_destruct:
            lib.hydra_post_destroy(byref(self._as_parameter_))

    def __eq__(self, other):
        if type(other) == type(self):
            return other.c_address() == self.c_address()
        elif type(other) == c_void_p:
            return other.value == self.c_address()

    def c_address(self):
        """
        Return the address of the object pointer in c.  Useful for comparison.
        """
        return addressof(self._as_parameter_.contents)

    def __bool__(self):
        "Determine whether the object is valid by converting to boolean" # Python 3
        return self._as_parameter_.__bool__()

    def __nonzero__(self):
        "Determine whether the object is valid by converting to boolean" # Python 2
        return self._as_parameter_.__nonzero__()

    def ident(self):
        """
        Recalculate the post ID based on subject, timestamp, parent id, MIME
type, and content digest, and return post ID to caller.
        """
        return lib.hydra_post_ident(self._as_parameter_)

    def subject(self):
        """
        Return the post subject, if set
        """
        return lib.hydra_post_subject(self._as_parameter_)

    def timestamp(self):
        """
        Return the post timestamp
        """
        return lib.hydra_post_timestamp(self._as_parameter_)

    def parent_id(self):
        """
        Return the post parent id, or empty string if not set
        """
        return lib.hydra_post_parent_id(self._as_parameter_)

    def mime_type(self):
        """
        Return the post MIME type, if set
        """
        return lib.hydra_post_mime_type(self._as_parameter_)

    def digest(self):
        """
        Return the post content digest
        """
        return lib.hydra_post_digest(self._as_parameter_)

    def location(self):
        """
        Return the post content location
        """
        return lib.hydra_post_location(self._as_parameter_)

    def content_size(self):
        """
        Return the post content size
        """
        return lib.hydra_post_content_size(self._as_parameter_)

    def content(self):
        """
        Return the post content as a string. Returns NULL if the MIME type is
not "text/plain". The caller must destroy the string when finished with it.
        """
        return return_fresh_string(lib.hydra_post_content(self._as_parameter_))

    def set_parent_id(self, parent_id):
        """
        Set the post parent id, which must be a valid post ID
        """
        return lib.hydra_post_set_parent_id(self._as_parameter_, parent_id)

    def set_mime_type(self, mime_type):
        """
        Set the post MIME type
        """
        return lib.hydra_post_set_mime_type(self._as_parameter_, mime_type)

    def set_content(self, content):
        """
        Set the post content to a text string. Recalculates the post digest from
from the new content value. Sets the MIME type to text/plain.
        """
        return lib.hydra_post_set_content(self._as_parameter_, content)

    def set_data(self, data, size):
        """
        Set the post content to a chunk of data. Recalculates the post digest
from the chunk contents. Takes ownership of the chunk. The data is not
stored on disk until you call hydra_post_save.
        """
        return lib.hydra_post_set_data(self._as_parameter_, data, size)

    def set_file(self, location):
        """
        Set the post content to point to a specified file. The file must exist.
Recalculates the post digest from the file contents. Returns 0 if OK, -1
if the file was unreadable.
        """
        return lib.hydra_post_set_file(self._as_parameter_, location)

    def save(self, filename):
        """
        Save the post to disk under the specified filename. Returns 0 if OK, -1
if the file could not be created. Posts are always stored in the "posts"
subdirectory of the current working directory. Note: for internal use
only.
        """
        return lib.hydra_post_save(self._as_parameter_, filename)

    @staticmethod
    def load(filename):
        """
        Load post from the specified filename. Posts are always read from the
"posts" subdirectory of the current working directory. Returns a new post
instance if the file could be loaded, else returns null.
        """
        return HydraPost(lib.hydra_post_load(filename), True)

    def fetch(self, size, offset):
        """
        Fetch a chunk of content for the post. The caller specifies the size and
offset of the chunk. A size of 0 means all content, which will fail if
there is insufficient memory available. The caller must destroy the chunk
when finished with it.
        """
        return czmq.Zchunk(lib.hydra_post_fetch(self._as_parameter_, size, offset), True)

    def encode(self, proto):
        """
        Encode a post metadata to a hydra_proto message
        """
        return lib.hydra_post_encode(self._as_parameter_, proto)

    @staticmethod
    def decode(proto):
        """
        Create a new post from a hydra_proto HEADER-OK message.
        """
        return HydraPost(lib.hydra_post_decode(proto), True)

    def dup(self):
        """
        Duplicate a post instance. Does not create a new post on disk; this
provides a second instance of the same post item.
        """
        return HydraPost(lib.hydra_post_dup(self._as_parameter_), True)

    def print(self):
        """
        Print the post file to stdout
        """
        return lib.hydra_post_print(self._as_parameter_)

    @staticmethod
    def test(verbose):
        """
        Self test of this class
        """
        return lib.hydra_post_test(verbose)


# hydra_ledger
lib.hydra_ledger_new.restype = hydra_ledger_p
lib.hydra_ledger_new.argtypes = []
lib.hydra_ledger_destroy.restype = None
lib.hydra_ledger_destroy.argtypes = [POINTER(hydra_ledger_p)]
lib.hydra_ledger_size.restype = c_int
lib.hydra_ledger_size.argtypes = [hydra_ledger_p]
lib.hydra_ledger_load.restype = c_int
lib.hydra_ledger_load.argtypes = [hydra_ledger_p]
lib.hydra_ledger_store.restype = c_int
lib.hydra_ledger_store.argtypes = [hydra_ledger_p, POINTER(hydra_post_p)]
lib.hydra_ledger_fetch.restype = hydra_post_p
lib.hydra_ledger_fetch.argtypes = [hydra_ledger_p, c_int]
lib.hydra_ledger_index.restype = c_int
lib.hydra_ledger_index.argtypes = [hydra_ledger_p, c_char_p]
lib.hydra_ledger_test.restype = None
lib.hydra_ledger_test.argtypes = [c_bool]

class HydraLedger(object):
    """
    work with Hydra ledger of posts
    """

    allow_destruct = False
    def __init__(self, *args):
        """
        Create a new empty ledger instance.
        """
        if len(args) == 2 and type(args[0]) is c_void_p and isinstance(args[1], bool):
            self._as_parameter_ = cast(args[0], hydra_ledger_p) # Conversion from raw type to binding
            self.allow_destruct = args[1] # This is a 'fresh' value, owned by us
        elif len(args) == 2 and type(args[0]) is hydra_ledger_p and isinstance(args[1], bool):
            self._as_parameter_ = args[0] # Conversion from raw type to binding
            self.allow_destruct = args[1] # This is a 'fresh' value, owned by us
        else:
            assert(len(args) == 0)
            self._as_parameter_ = lib.hydra_ledger_new() # Creation of new raw type
            self.allow_destruct = True

    def __del__(self):
        """
        Destroy the ledger
        """
        if self.allow_destruct:
            lib.hydra_ledger_destroy(byref(self._as_parameter_))

    def __eq__(self, other):
        if type(other) == type(self):
            return other.c_address() == self.c_address()
        elif type(other) == c_void_p:
            return other.value == self.c_address()

    def c_address(self):
        """
        Return the address of the object pointer in c.  Useful for comparison.
        """
        return addressof(self._as_parameter_.contents)

    def __bool__(self):
        "Determine whether the object is valid by converting to boolean" # Python 3
        return self._as_parameter_.__bool__()

    def __nonzero__(self):
        "Determine whether the object is valid by converting to boolean" # Python 2
        return self._as_parameter_.__nonzero__()

    def size(self):
        """
        Return ledger size, i.e. number of posts stored in the ledger.
        """
        return lib.hydra_ledger_size(self._as_parameter_)

    def load(self):
        """
        Load the ledger data from disk, from the specified directory. Returns
the number of posts loaded, or -1 if there was an error reading the
directory.
        """
        return lib.hydra_ledger_load(self._as_parameter_)

    def store(self, post_p):
        """
        Save a post via the ledger. This saves the post to disk, adds the post
to the ledger, and then destroys the post. Use in place of
hydra_post_save to ensure post filenames are correctly generated.
        """
        return lib.hydra_ledger_store(self._as_parameter_, byref(hydra_post_p.from_param(post_p)))

    def fetch(self, index):
        """
        Return post at specified index; if the index does not refer to a valid
post, returns NULL.
        """
        return HydraPost(lib.hydra_ledger_fetch(self._as_parameter_, index), True)

    def index(self, post_id):
        """
        Lookup post in ledger and return post index (0 .. size - 1); if the post
does not exist, returns -1.
        """
        return lib.hydra_ledger_index(self._as_parameter_, post_id)

    @staticmethod
    def test(verbose):
        """
        Self test of this class
        """
        return lib.hydra_ledger_test(verbose)

################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
